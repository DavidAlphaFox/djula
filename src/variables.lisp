(in-package #:djula)

;;; truncatechars:"30" => (:truncatechars 30)
(defun parse-filter-string (string)
  (if-let ((colon (position #\: string)))
    (list (make-keyword (string-upcase (subseq string 0 colon)))
          (string-trim '(#\") (subseq string (1+ colon))))
    (list (make-keyword (string-upcase string)))))

;;; foo.bar.baz.2 => (:foo :bar :baz 2)
(defun parse-variable-phrase (string)
  (flet ((interp (s)
	   (if (every 'digit-char-p s)
	       (parse-integer s)
	       (make-keyword (string-upcase s)))))
    (if-let ((dot (position #\. string)))
      (cons (interp (subseq string 0 dot))
            (parse-variable-phrase (subseq string (1+ dot))))
      (list (interp string)))))

;;; foo.bar.baz.2 | truncatechars:"30" | upper => ((:foo :bar :baz 2) (:truncatechars 30) (:upper))
(defun parse-variable-clause (unparsed-string)
  (destructuring-bind (var . filter-strings)
      (mapcar (lambda (s)
                (string-trim '(#\space #\tab #\newline #\return) s))
	      (split-sequence:split-sequence #\| unparsed-string))
    (cons (parse-variable-phrase var)
          (mapcar #'parse-filter-string filter-strings))))

(def-token-processor :unparsed-variable (unparsed-string) rest
  ":PARSED-VARIABLE tokens are parsed into :VARIABLE tokens by PROCESS-TOKENS"
  (cons (list* :variable (parse-variable-clause unparsed-string))
        (process-tokens rest)))

(defun apply-keys/indexes (thing keys/indexes)
  (reduce (lambda (thing key)
            (handler-case
                (if (numberp key)
                    (elt thing key)
                    (access thing key))
              (error ()
                (template-error-string
                 "There was an error while accessing the ~A ~S of the object ~S"
                 (if (numberp key)
                     "index"
                     "attribute")
                 key
                 thing))))
          keys/indexes
          :initial-value thing))

(defun get-variable (name)
  "takes a variable `NAME' and returns:
   1. the value of `NAME'
   2. any error string generated by the lookup (if there is an error string then the
      lookup was unsuccessful)"
  (or (access *template-arguments* name)
      (and *use-example-values-p*
           (some (lambda (table)
                   (destructuring-bind (path . plist)
                       table
                     (access plist name)))
                 *known-example-tables*))))

(defun resolve-variable-phrase (list)
  "takes a list starting wise a variable and ending with 0 or more keys or indexes [this
is a direct translation from the dot (.) syntax] and returns two values:

   1. the result [looking up the var and applying index/keys]
   2. an error string if something went wrond [note: if there is an error string then
the result probably shouldn't be considered useful."
  (aand (get-variable (first list))
        (apply-keys/indexes it (rest list))))

(def-token-compiler :variable (variable-phrase &rest filters)
  ;; check to see if the "dont-escape" filter is used
  (let ((dont-escape
         (find '(:safe) filters :test #'equal)))
    ;; return a function that resolves the variable-phase and applies the filters
    (lambda (stream)
      (multiple-value-bind (ret error-string)
          (resolve-variable-phrase variable-phrase)
        (if error-string
            (with-template-error error-string
              (error error-string))
            (let ((str (princ-to-string (or ret ""))))
              (princ (apply-filters (if dont-escape
                                        str
                                        (escape-for-html str))
                                    filters)
                     stream)))))))

;;; making sure all the variables in an example table are in *TEMPLATE-ARGUMENTS*
(defun .check-example-table-plist (example-table-plist)
  (when example-table-plist
    (destructuring-bind (k v . rest) example-table-plist
      (declare (ignore v))
      (aif (nth-value 1 (get-variable k))
	   (cons it #1=(.check-example-table-plist rest))
	   #1#))))
